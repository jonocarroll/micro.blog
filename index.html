<!DOCTYPE html>
<html>

  <head>
	<meta name="generator" content="Hugo 0.91.2" />

  <title>
      
      Jonathan Carroll&#39;s micro blog
      
  </title>

</head>


  <body>

    

	
<div class="h-feed">

	
	
	  <div class="h-entry">
		
			<h1><a href="https://jcarroll.xyz/2022/04/07/interpolation-animation-in.html">Interpolation animation in Julia</a></h1>
		

		<a href="https://jcarroll.xyz/2022/04/07/interpolation-animation-in.html" class="u-url"><time class="dt-published" datetime="2022-04-07 21:07:00 &#43;0930">Apr 7, 2022</time></a>

		<div class="e-content">
			 <p>I <em>love</em> small projects for helping me learn, especially programming. I&rsquo;m still learning Julia, and have found myself wanting more &ldquo;little silly things&rdquo; I can digest and learn from. A lot of the projects I see in Julia are big mathematical models, and I&rsquo;m just not ready to dive that deep yet.</p>
<p><a href="https://twitter.com/ted_dunning/status/1435027697386721280?s=20&amp;t=cDVb0XOQRJeOjXoTrOz54w">This series of tweets</a> caught my eye, partly because of the cool animation, but also the bite-sized amount of information it was conveying - that interpolation in Julia can be specified so easily, thanks in large part to the multiple dispatch design of the language.</p>
<p>&ldquo;Surely I could get those 7 lines of code to run&rdquo; I thought.</p>
<p>Entering the code into VScode was straightforward enough, no problems there. I could define the interpolation function</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">interpolate(a, b) = t -&gt; ((1.0-t)*a + t*b)
</code></pre><p>however extending the <code>*</code> and <code>+</code> methods did require me to <code>import Base:*</code> and <code>import Base:+</code> which I think I knew but had forgotten.</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">+(f::Function, g::Function) = x -&gt; f(x) + g(x)
*(t::Number, g::Function) = x -&gt; t * g(x)
</code></pre><p>Defining the secondary and tertiary interpolations, also straightforward</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">bz1(p1, p2) = interpolate(p1, p2)
bz2(p1, p2, p3) = interpolate(bz1(p1, p2), bz1(p2, p3))
bz3(p1, p2, p3, p4) = interpolate(bz2(p1, p2, p3), bz2(p2, p3, p4))
</code></pre><p>Now the tricky part - evaluating some of these. I knew that <code>a</code> and <code>b</code> represent points, but how to do that here? They&rsquo;re not single numbers, but coordinates. I tried a <code>Tuple</code> as <code>(1, 2)</code> but that doesn&rsquo;t seem to work. I do need to remember that <code>interpolate</code> is itself a function of <code>t</code>, so that needs to be specified as well. If I try to interpolate halfway between two &ldquo;points&rdquo; with <code>Tuple</code>s</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">interpolate((0,1), (1,2))(0.5)
ERROR: MethodError: no method matching *(::Float64, ::Tuple{Int64,Int64})
Closest candidates are:
  *(::Any, ::Any, ::Any, ::Any...) at operators.jl:538
  *(::Float64, ::Float64) at float.jl:405
  *(::AbstractFloat, ::Bool) at bool.jl:112
</code></pre><p>Okay, how about <code>Array</code>s?</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">interpolate([0,1], [1,2])(0.5)
2-element Array{Float64,1}:
 0.5
 1.5
</code></pre><p>Huzzah!</p>
<p>After that, it&rsquo;s a matter of generating the points specified by</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">bz3(p1, p2, p3, p4)(t)(t)(t)
</code></pre><p>for various values of <code>t</code>. I did that with a <code>map</code> and joined the results back into a single <code>Array</code></p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">dots = map(i -&gt; bz3(p1, p2, p3, p4)(i)(i)(i),collect(0:0.1:1))
dots = hcat(dots...)
dots
2×11 Array{Float64,2}:
 0.5  0.47535  0.5368  0.66245  …  1.36905  1.4872  1.53815  1.5
 1.0  1.3124   1.5312  1.6588      1.3052   1.0128  0.6436   0.2
</code></pre><p>That was, I&rsquo;d say, a success.</p>
<p>Drunk with confidence, I wanted to try to reproduce the animation from the tweet, so I dug into the documentation. It didn&rsquo;t seem too bad, and I think I&rsquo;ve managed to reproduce it pretty well</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">anim = @animate for t in collect(vcat(0:0.01:1,1:-0.01:0))
    a = bz3(p1, p2, p3, p4)(t)(t)(t);
    b1 = bz2(p1, p2, p3)(t)(t);
    b2 = bz2(p2, p3, p4)(t)(t);
    c1 = bz1(p1, p2)(t);
    c2 = bz1(p2, p3)(t);
    c3 = bz1(p3, p4)(t);
    stars = hcat(p1, p2, p3, p4);
    diamond1 = hcat(c1, c2);
    diamond2 = hcat(c2, c3);
    square = hcat(b1, b2);
    plot(xlim = (-0.1,2.5), ylim = (-0.1,2.5), legend = false)
    scatter!(dots[1,:], dots[2,:], markersize = 2)
    plot!(diamond1[1,:], diamond1[2,:], markersize = 10, markershape = :diamond, color = :green)
    plot!(diamond2[1,:], diamond2[2,:], markersize = 10, markershape = :diamond, color = :green)
    plot!(square[1,:], square[2,:], markersize = 10, markershape = :square, color = :blue)
    plot!(stars[1,:], stars[2,:], markersize = 10, markershape = :star, color = :purple)
    scatter!(Tuple(a), markersize = 10, markershape = :circle, markercolor = :red)
end

gif(anim, fps = 24)
</code></pre><p><img src="https://jcarroll.xyz/uploads/2022/ea5f75012f.gif" alt=""></p>
<p>Moving the points around, I get a new version all of my own</p>
<p><img src="https://jcarroll.xyz/uploads/2022/b776bf8259.gif" alt=""></p>
<p>I&rsquo;m very happy with how these turned out, and I&rsquo;ve learned a lot! A gist of the code to make these is hosted here: <a href="https://gist.github.com/jonocarroll/27f9b57332424ea50ec2970e74d8e3b3">https://gist.github.com/jonocarroll/27f9b57332424ea50ec2970e74d8e3b3</a></p>
<p>If there are better ways to do any of the steps (there surely are) please feel free to let me know!</p>
<p>Was this fun? You Bezier ass!</p>

		</div>
	  </div>
	
	  <div class="h-entry">
		
			<h1><a href="https://jcarroll.xyz/2022/03/25/r-challenge-contour.html">R challenge - contour in a matrix</a></h1>
		

		<a href="https://jcarroll.xyz/2022/03/25/r-challenge-contour.html" class="u-url"><time class="dt-published" datetime="2022-03-25 22:02:00 &#43;0930">Mar 25, 2022</time></a>

		<div class="e-content">
			 <p>As part of what will hopefully become a larger post, I&rsquo;m interested in finding an R way to achieve the following: given an <code>n x n</code> matrix of zeroes with a single non-zero element of some value <code>v</code>, fill the surrounding entries such that each other element is at most one less than those surrounding it (up or down). For example, with an <code>8x8</code> matrix with a value of <code>5</code> at <code>c(5, 5)</code>, the result would be</p>
<pre tabindex="0"><code>     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    0    0    0    0    1    0    0    0
[2,]    0    0    0    1    2    1    0    0
[3,]    0    0    1    2    3    2    1    0
[4,]    0    0    2    3    4    3    2    1
[5,]    1    2    3    4    5    4    3    2
[6,]    0    1    2    3    4    3    2    1
[7,]    0    0    1    2    3    2    1    0
[8,]    0    0    0    1    2    1    0    0
</code></pre><p>This is somewhat akin to imposing a contour density on top of a single peak, but I really can&rsquo;t find any suitable approaches. Convolutions came to mind, but I can&rsquo;t think of or find the appropriate kernel.</p>
<p>Let me know if you have one!</p>
<h2 id="update">Update:</h2>
<p>Thanks to <a href="https://twitter.com/yjunechoe/status/1507344665514848258?s=20&amp;t=27rn8zNl-36D-3ppsslAjw">June Choe</a>, this code using <code>outer()</code> produces the desired matrix for a point at <code>c(vx, vy)</code> with value <code>vv</code> in a <code>n x n</code> matrix</p>
<pre tabindex="0"><code>vx &lt;- 4
vy &lt;- 3
vv &lt;- 5
n &lt;- 8
outer(1:n, 1:n, function(x, y) pmax(vv - abs(x - vx) - abs(y - vy), 0))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    0    1    2    1    0    0    0    0
[2,]    1    2    3    2    1    0    0    0
[3,]    2    3    4    3    2    1    0    0
[4,]    3    4    5    4    3    2    1    0
[5,]    2    3    4    3    2    1    0    0
[6,]    1    2    3    2    1    0    0    0
[7,]    0    1    2    1    0    0    0    0
[8,]    0    0    1    0    0    0    0    0
</code></pre>
		</div>
	  </div>
	
	  <div class="h-entry">
		
			<h1><a href="https://jcarroll.xyz/2022/03/20/rowwise-optimizations-in.html">ByRow optimizations in Julia</a></h1>
		

		<a href="https://jcarroll.xyz/2022/03/20/rowwise-optimizations-in.html" class="u-url"><time class="dt-published" datetime="2022-03-20 13:11:00 &#43;0930">Mar 20, 2022</time></a>

		<div class="e-content">
			 <p>I&rsquo;m still fairly new to Julia, even though I&rsquo;ve been trying to learn it for a few years. It&rsquo;s <em>extremely</em> powerful (fast, expressive, &hellip; whatever metric you want to use) but with that comes some complexity.</p>
<p>I saw <a href="https://bkamins.github.io/julialang/2022/02/25/anyall.html">this post</a> in my feed and it seemed like a great bite-sized chunk of code to learn from. I <em>think</em> I understand everything that&rsquo;s happening, even if I certainly couldn&rsquo;t write that myself, with one exception.</p>
<p>The connection that for <code>Bool</code> data, <code>all()</code> is equivalent to <code>minimum()</code> (it&rsquo;s false as soon as there is one 0, otherwise it&rsquo;s true) and <code>any()</code> is equivalent to <code>maximum()</code> (if there&rsquo;s a 1 it&rsquo;s true) took me a moment, but seems pretty cool. That wasn&rsquo;t the problem I had.</p>
<p>The bit that surprised me was that for <code>ByRow</code> calculations on a <code>DataFrame</code>, <code>minimum()</code> is <strong>faster</strong> than <code>all()</code>. The reason this is so surprising for me is that I understand <code>all()</code> from an R-perspective and my understanding was that <code>all()</code> could short-circuit because as soon as it sees a <code>FALSE</code> it can ignore any other values - the result is guaranteed to be <code>FALSE</code> (yes, yes, up to missingness). Surely, a calculation of <code>minimum()</code> needs to evaluate every value at least once (?). Where this might (must?) fall apart is that I&rsquo;m thinking purely of vectors. Sure enough, checking out some timings on a vector in Julia shows <code>all()</code> is near-instantaneous (after compilation)</p>
<pre tabindex="0"><code class="language-{julia}" data-lang="{julia}">x = rand(Bool, 100_000_000)

@time all(x)
  0.009047 seconds (218 allocations: 9.531 KiB, 99.85% compilation time)
false

@time all(x)
  0.000002 seconds
false

@time minimum(x)
  0.091183 seconds (85.03 k allocations: 4.461 MiB, 41.98% compilation time)
false

@time minimum(x)
  0.052287 seconds
false
</code></pre><p>I get similar results, expectedly, from R</p>
<pre tabindex="0"><code class="language-{r}" data-lang="{r}">x &lt;- sample(c(TRUE, FALSE), 1e8, replace = TRUE)
microbenchmark::microbenchmark(
  min = max(x),
  any = any(x),
  times = 10
)
# Unit: nanoseconds
#  expr       min        lq        mean    median        uq       max neval
#   min 208741173 210539351 223219500.3 212388892 222673528 285974960    10
#   any       160       187      2403.4       295      5095      7451    10
</code></pre><p>So, what&rsquo;s going on? I <em>think</em> the answer is that we&rsquo;re not dealing with just a vector, it&rsquo;s rows from a <code>DataFrame</code>, right? Now, from the R side, that&rsquo;s complicated enough - <code>rowwise()</code> is a <a href="https://speakerdeck.com/jennybc/row-oriented-workflows-in-r-with-the-tidyverse">necessary thing</a> because R stores a <code>data.frame</code> as a list of vectors representing <em>columns</em>, so extracting a row means slicing across those.</p>
<p>I can reproduce the speedup in Julia (and honestly, I struggle to find a clean and fast way to do it in R) but the statement &ldquo;<a href="https://bkamins.github.io/julialang/2022/02/25/anyall.html#:~:text=This%20time%20things%20are%20very%20fast%2C%20as%20row%2Dwise%20aggregation%20for%20maximum%20and%20minimum%20is%20optimized.">This time things are very fast, as row-wise aggregation for maximum and minimum is optimized.</a>&rdquo; got me thinking - where should I have learned that? Google isn&rsquo;t showing me any relevant results, so is this just a known thing? I can imagine that such an optimization for doing this might exist, but can anyone provide a reference or guide?? The author of the blog post used this optimization in a <a href="https://stackoverflow.com/a/71209103/4168169">StackOverflow answer</a> without challenge (no reference provided) so I feel like it&rsquo;s potentially just something I should know.</p>

		</div>
	  </div>
	
	  <div class="h-entry">
		
			<h1><a href="https://jcarroll.xyz/2022/03/20/first-post-on.html">First post on jcarroll.xyz</a></h1>
		

		<a href="https://jcarroll.xyz/2022/03/20/first-post-on.html" class="u-url"><time class="dt-published" datetime="2022-03-20 11:28:39 &#43;0930">Mar 20, 2022</time></a>

		<div class="e-content">
			 <p>I like blogging, but in the spirit of lowering the resistance to getting posts out, I&rsquo;ve started a micro blog <a href="https://jcarroll.xyz">jcarroll.xyz</a> where I&rsquo;ll capture shorter, less polished pieces and random thoughts / snippets.</p>
<p>This is my first post, testing all the functionality. DNS might still take a little while, so don&rsquo;t worry if you see my full blog when you click the link.</p>

		</div>
	  </div>
	

</div>


    
    

  </body>

</html>
